{"title": "AngularJS中ng-bind-html细节问题", "content": "  AngualrJS 提供了指令ng-bind-html 用于绑定包含HTML标签的文档，官方和大多数给的用法是\n    绑定 <p> 内的 innerHTML 到变量 \n:\n \n \n      \n \n        var app = angular.module(\"myApp\", ['ngSanitize']);\n        app.controller(\"myCtrl\", function($scope) {\n        $scope.myText = \"My name is: <h1>John Doe</h1>\";\n      });\n实际上这样用会由于安全AngularJS机制而报错\n错误如下\n之前用JQuery的.html()用一般不用考虑多少，今天使用AngularJs时候遇到这个问题，困扰了许久，在stackoverflow找到了解决方法。\n \n该指令通俗意思是该html是可信耐的。\n如果有时候我们的数组中对象某些需要通过ng-bind-html来绑定，那我我必须依次遍历加入上面 “可信耐”的代码\n比如我的article是一个文章的数组，其中title和content包含html格式，则我么需要依次加入 “可信耐”的代码"}
{"title": "Struts2动态Action编写方法总结", "content": "。\n     在同一个Action中写多个方法，通过\n调用方法\n    \n    <form action=\"\n\" ></form>\n    struts.xml中\n    \n    \n   "}
{"title": "IDEA自动部署项目到远程服务器", "content": "    IDEA被认为是开发java最好的的工具，没有之一，在开发java从MyEclipse转到IDEA半年中，被他强大的智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面所惊叹，在最近开发项目中，经常重复性部署项目，还借助第三方ftp上传工具，今天突然想IDEA这么强大的工具应该集成ftp和ssh等工具，随便查了下果然是有的。经过几次尝试，IDEA自带的部署果然好用，简单介绍下用法及配置。\n在File | settings中找到Deployment\n点击加号添加服务器\n点击Test SFTP连接成功则输入用户名和密码正确。\n在mapping一栏则填写上传到服务器目录信息\n重点LocalPath表示你要上传的本地目录，这里目录写你项目编译好的文件或者war包。\nDeployment path on server\n你要上传的服务器目录，这里填写你的http服务器目录，如果是java工程，用tomcat则填写Tomcat的webapps目录\nwep path on server\n这是你要给http访问的的相对ROOT目录的二级目录，\n比如你Deployment Path写的是/home/tomcat8/webapps/ROOT/\nWeb Path写的目录是 /  最终上传的目录是 /home/tomcat8/webapps/ROOT/\n比如你Deployment Path写的是/home/tomcat8/webapps/ROOT/\nWeb Path写的目录是/test  最终上传的目录是 /home/tomcat8/webapps/ROOT/test\n总结 最终上传文件所在目录是 Deployment Path + Web Path\n填写完毕后就可以一键上传项目到远程服务器了。\n在很多前后端分离的项目中，我们可以多次配置，分别上传不同服务器和同一服务器不同路径。\n如图所示"}
{"title": "Ubuntu Linux 14.04设置ssh允许root远程登录", "content": "ubuntu14.04默认是不能以ssh远程登录的，这是为了防止root用户权限过大引起的不安全操作，通常我们以非root用户登录\n当需要权限的时候执行sudo或者直接su切换到root用户，这样有时候不怎么方便，当我们修改ssh的配置文件时候，就可以以\nroot用户登录\nsudo vim /etc/ssh/sshd_config\n找到 PermitRootLogin without-password\n修改箭头中部分\n改成 PermitRootLogin yes\n重启ssh服务就可以了\nsudo service ssh restart"}
{"title": "Spring中AOP的解释", "content": ""}
{"title": "centos7 1611版本安装pip", "content": "centos7 1611版本安装完后,直接安装yum install python-pip是无法安装的，说找不到该软件\n将yum 源设置成阿里源就可以了 \n操作步骤\n下载\nwget http://mirrors.aliyun.com/repo/Centos-7.repo\n替换\ncp Centos-7.repo /etc/yum.repos.d/\n清除旧缓存\nrm -rf /var/cache/yum\n生成缓存并更新yum源\nyum makecache\nyum update\n安装pip\nyum install python-pip\n默认安装完的pip不是最新的 需要更新\npip install --upgrade pip\n安装完执行pip --version \n已经是最新的"}
{"title": "微信前端框架 jQuery WeUI", "content": " 是微信官方团队针对微信提供的一个H5 UI库，它只提供了一组CSS组件。jQuery WeUI 中使用的是官方WeUI的CSS代码，并提供了jQuery/Zepto版本的API实现。因为直接使用了官方的CSS，所以你不用担心跟官方版本的冲突。实际上 jQuery WeUI == WeUI + jQuery插件。\n推荐通过npm获取代码: npm install jquery-weui\n依次引入如下文件后即可使用："}
{"title": "python本地代码服务器端调试", "content": "    最近python开发经常遇到了本地代码环境与服务器端环境不一样的问题，遇到问题就打日志一行行查看日志找出问题出在哪里。这种方法效率很低，有没有直接本地代码进行服务器端远程调试运行呢。答案是有的。尝试了网上很多方法，有的十分复杂，需要一大堆软件支持。最终发现PyCharm不需要下载任何插件，原生支持本地代码服务器调试，jetBrans出品的开发工具IDEA,PyCharm果然个个是精品。\n    简单介绍下如何用PyCharm进行本地代码服务器端调试。\n    1 依次找到settings -> Build,Excution,Deployment -> Deployment  填写远程服务器服务器用户名密码\n    \n2  切到Mapping 这一栏   1 处填写你本地代码的路径   2处填写  你代码将要保存的服务器路路径  填写完成apply\n3  找到 setting -> Project Interpreter -> 右边add romote \n4 依次填写 服务器ip用户名 密码  注意打星的地方 默认用的是服务器的python2 你服务器如果装了python3 应写成/usr/bin/python3\n5 填写完成后 python解释器就会出现两个 一个是你本地的 一个是你服务器的\n6  将解释器调成服务器解释器 写端代码测试下 ，写完代码上传服务器\n         \n 当你写了很多代码时候 想要查看本地代码与服务器区别 是否同步 可以如下操作\n        \n \n7 运行下代码\n    \n  debug 模式也是支持的\n    "}
{"title": "centos7安装python3 pip3", "content": "      python3发布已经几年了，但现在绝大多数Linux系统预装的都是python2.7,最近尝试在centos7上安装python3和pip3折腾了好久，走过很多坑，尝试了很多种方法，失败了很多次，最终安装成功。现在总结下安装过程。\n  我采用的是源码编译安装，源码安装有个很大问题是依赖问题。\n 需要的依赖有\n编译安装\n编译完成后 /usr/local/bin目录下有python3.5和pip3.5文件\n这样就在系统命令中有了python3和pip3"}
{"title": "题目 动态秘钥简介", "content": " \n \nA\nA\n \n \n \n \nkey\n \nSimple  dynamic  key  I  will  say  hello\n \nASCII\na  a  a  a  a  s   i\n       1  2  3  a  b  9  2   x  x  x \n     q   r  s  m  n  q  z \n \nq\n1\nq\n \n \n \n \na-z\na - z  0-9 \na-z\n \n \nASCII\n \n \n \n Simple  dynamic  key  I  will  say  hello\n  \n  \n   \n  \n \n10\n30"}
{"title": "ubuntu / debian  Linux安装MySQL简单方法", "content": "ubuntu 或者debian桌面，服务器 发行版的软件仓库中有MySQL软件，安装MySQL非常简单，比windows下安装MySQL简单多了\n只需要一个命令即可\n首先切换到Root用户\n然后 \n就开始执行安装，按照提示设置密码\n设置完成等待安装完成\n测试安装是否成功\nmysql -u root -p \n输入密码\n出现mysql提示和版本信息安装成功！"}
{"title": "Linux中~/.等符号的含义", "content": "在Linux为了快速到达某些目录 经常用到 ~ /  . 等符号下面简单介绍下这些符号的含义\n.  代表当前目录本身 一般可以不写\n  所以\n 和\n和\n效果是一样的"}
{"title": "​统计单词数", "content": "统计单词数  \n时间限制：1.0s   内存限制：512.0MB\n    \n问题描述\n　　统计输入英文文章段落中不同单词（单词有大小写之分,　　但统计时忽略大小写）各自出现的次数。 输入段落中所含单词的总数不超过100，最长单词的长度不超过20个字母.\n输入格式\n　　一个包含若干句子的段落, 每个句子由若干英文单词组成. 除空格,　　逗号和句号外, 这些输入的句子中不含其他非字母字符, 并且, 逗号和句号紧跟在它前面的英文单词后面, 中间没有空格. 段落最后一个字符是回车符,　　表示输入结束.\n输出格式\n　　若段落中共有M个不同的英文单词，则按照其在段落中出现的先后顺序输出M行，各行的格式为:　　单词中所有字母均用大写形式输出（最长的单词顶格输出，它前面没有多余的空格;　　其余单词与其右对齐）+冒号+N个*号+该单词在段落中的出现次数N\n样例输入\nThis is a test. This test is easy. This is a test. This test is easy.\n样例输出\nTHIS:****4\nIS:****4\nA:**2\nTEST:****4\nEASY:**2"}
{"title": "python装饰器解读", "content": " 装饰器是python开发常用的一个强大功能，对于懂java的人来说，语法特性类似java的注解，但是python的装饰器使用远远比java的注解简单，但功能毫不逊色java的注解。但对于有些人来说，这个用法有点绕，下面通过我的解读，相信你一定能熟悉使用装饰器。\n现实开发中，当你开发快要完成时候，现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码：\n写代码要遵循开发封闭原则,简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即：\n封闭：已实现的功能代码块\n开放：对扩展开发\n如果fun2  fun3有类似需求。怎么做，在每个函数里面写？这样造成大量重复代码。我们可以这样做，重新定义一个函数：专门处理日志 ，日志处理完之后再执行真正的业务代码\n使用时候\n这样写很容易理解 我们每次都要将一个函数作为参数传递给use_logging函数。\n而且这种方式已经破坏了原有的代码逻辑结构，之前执行业务逻辑时，执行运行func()，但是现在不得不改成use_logging(func)。那么有没有更好的方式的呢？当然有，答案就是装饰器。\n简单装饰器\n函数use_logging就是装饰器，它把执行真正业务方法的func包裹在函数里面，\n看起来像func被use_logging装饰了。在这个例子中，函数进入和退出时 ，\n被称为一个横切面(Aspect)，这种编程方式被称为面向切面的编程(Aspect-Oriented Programming)。\n@符号是装饰器的语法糖，在定义函数的时候使用，避免再一次赋值操作\n如上所示，这样我们就可以省去func = use_logging(func)这一句了，直接调用func()即可得到想要的结果。\n如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。\n这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。\n装饰器在Python使用如此方便都要归因于Python的函数能像普通的对象一样能作为参数传递给其他函数，\n可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。\n装饰器还有更大的灵活性，例如带参数的装饰器：在上面的装饰器调用中，\n比如@use_logging，该装饰器唯一的参数就是执行业务的函数。\n装饰器的语法允许我们在调用时，提供其它参数，比如@decorator(a)。\n这样，就为装饰器的编写和使用提供了更大的灵活性。\n上面的use_logging是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。\n我们可以将它理解为一个含有参数的闭包。当我 们使用@use_logging(level=\"warn\")调用的时候，\nPython能够发现这一层的封装，并把参数传递到装饰器的环境中。\n类装饰器\n再来看看类装饰器，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。\n使用类装饰器还可以依靠类内部的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。\n使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表，先看例子：\n装饰器\n函数\n该函数完成等价于：\n不难发现，函数f被with_logging取代了，当然它的docstring，__name__就是变成了with_logging函数的信息了。\n这个问题就比较严重的，好在我们有functools.wraps，wraps本身也是一个装饰器，\n它能把原函数的元信息拷贝到装饰器函数中，这使得装饰器函数也有和原函数一样的元信息了。\n@staticmathod、@classmethod、@property\n@a\n@b\n@c\ndef f ():\n     pass\n等效于\n f = a(b(c(f)))\n代码详见 \n下一篇将介绍装饰器的使用案例"}
{"title": "MD5加密", "content": ""}
{"title": "FJ 字符串", "content": "问题描述\n　　FJ在沙盘上写了这样一些字符串：\n　　A1 = “A”\n　　A2 = “ABA”\n　　A3 = “ABACABA”\n　　A4 = “ABACABADABACABA”\n　　… …\n　　你能找出其中的规律并写所有的数列AN吗？\n输入格式\n　　仅有一个数：N ≤ 26。\n输出格式\n　　请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。\n样例输入\n3\n样例输出\nABACABA"}
{"title": "Huffman树构造", "content": "问题描述\n　　Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。\n　　给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下：\n　　1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。\n　　2. 重复步骤1，直到{pi}中只剩下一个数。\n　　在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。\n　　本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。\n　　例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下：\n　　1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。\n　　2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。\n　　3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。\n　　4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。\n　　5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。\n输入格式\n　　输入的第一行包含一个正整数n（n<=100）。\n　　接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。\n输出格式\n　　输出用这些数构造Huffman树的总费用。\n样例输入\n5\n5 3 8 2 9\n样例输出\n59\n编者 超锅 转载请说明出处"}
{"title": "制作各种系统启动盘方法总结", "content": "作为一个搞IT的，常年都备了几个系统盘，以备不时之需，当系统出问题时候，可以用系统盘拯救或者恢复。制作系统盘工具和方法有很多，下面说下我使用的方法。\n1.windows\n  a.windows的启动盘制作比较简单，最简单的是可以使用老毛桃，大白菜这类winPE系统来制作一个启动盘，然后将系统丢启动盘里面，安装时候选中安装镜像就可以了，这种安装方式比较傻瓜，基本什么操作都是一键就可以完成。这种方式安装比较适合没有装机基础的人，容易上手，但这种方式有个很恶心的地方，就是用这些大白菜，老毛桃工具安装完后会捆绑一大堆推广软件。虽然安装完系统可以删除。\n        b.第二种方式，一种比较纯净的方式，适合有基础的人。使用UltraISO光驱写入软件，该方法适合正版windows（不适合ghost系统）和Linux系统，步骤如下\n       使用UltraISO ->文件->打开->打开ios文件\n        \n      \n       点击启动 ->写入硬盘映像\n    \n        \n        注意硬盘驱动器那项 ，选择你的u盘 不要选错了，要是选错了选成了硬盘或者移动硬盘，会把整个盘清空\n    \n    \n    一切查看没有问题后直接点击写入，等待5-10分钟后就可以了。\n2.Linux\n   Linux安装基本上只能使用光驱写入工具来完成，特别强调，大白菜，老毛桃这样的winPE不能用来安装Linux。每个Linux系统发型版 centos ubuntu debian 官方都提供了免费的镜像写入工具，我都使用过，基本步骤都是打开选择镜像，然后写入镜像。上面介绍的UltraISO也可以用来制作Linux系统启动盘，方法步骤与上面制作windows启动盘一样。\nMBR方式安装是传统的方式，安装没有什么特别，不做介绍，uefi安装就比较复杂，支持uefi需要主板bios支持和系统支持，怎么查看主板时候支持uefi，首先进入bios,查看boot module选项 是否有uefi support ，据我观察。13年之后的主板都都开始支持uefi方式启动了。主板支持uefi方式，得需要系统支持，win7 64位以上系统都支持uefi方式启动，Linux系统我目前用过的ubuntu 14以上。centos7 以上也支持uefi方式启动。\nbios和系统都支持了，接下来开始制作uefi方式的启动盘，首先的把bios设置成支持uefi模式，一般bios支持uefi启动，但不一定打开了，若没有打开，需要手动打开uefi支持。\nwindows正版系统ios文件和Linux的uefi启动盘都可以用光驱写入工具制作，制作方式上面有介绍。"}
{"title": "MySQl备份成sql", "content": "当mysql数据文件比较小时候 可以用备份成sql脚本形式\n/home/super/blog201608082313.sql\n备份成功后可以看到在指定位置产生了.sql文件"}
{"title": "SpringMVC入门非注解开发配置01", "content": "1 在WEB-INF\\web.xml中配置前端控制器\n      \n2 在classpath下新建 \n文件 建议新建一个source folder命名为config然后在下面新配置建文件\n3 依次配置处理器映射器 处理器适配器 视图解析器 并新建一个Hander\n \n4 新建hander\nSpring简单非注解程序配置完成 "}
{"title": "SpringMVC常见注解", "content": "Spring MVC常见注解\n@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。\nRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。\n1、 value， method；\nvalue：     指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；\nmethod：  指定请求的method类型， GET、POST、PUT、DELETE等；\n2、consumes，produces\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;\nproduces:    指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\n3、params，headers\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\nheaders： 指定request中必须包含某些指定的header值，才能让该方法处理请求。\n@Resource和@Autowired都是做bean的注入时使用\n1、共同点\n两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。\n2、不同点\n（1）@Autowired\n@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。\n@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配\n@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。\n代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。\n @SessionAttributes即将值放到session作用域中，写在class上面。\n用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数\n@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(\"name\")，它有三个常用参数：defaultValue = \"0\", required = false, value = \"isApp\"；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。\n作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。\n使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用；\n相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。\n用于注解dao层，在daoImpl类上面注解。"}
{"title": "一些脚本", "content": "清理C盘垃圾的批处理脚本"}
{"title": "求10亿以内质数和的最快算法（java语言版）", "content": ""}
{"title": "Linux系统写c语言程序步骤", "content": "使用vim/vi 简单编辑器\n新建一个文件夹 mkdir testc 会在用户目录下生成一个testc文件夹\n进入该文件夹 \n使用vim编辑器  \n按 i 进入插入模式\n输入\n按 esc 退出插入模式\n保存并退出 \n    \n//    ./表示当前目录"}
{"title": "集合框架List Set Map浅谈", "content": "  \n        |--ArrayList:底层的数据结构使用的是数组结构。特点：查询速度很快。但是增删稍慢。\n。\n        |--LinkedList:底层使用的链表数据结构。特点：增删速度很快，查询稍慢。\n        |--Vector:底层是数组数据结构。\n被ArrayList替代了。因为效率低。\n    |--HashSet：\n                保证元素唯一性的原理：判断元素的hashCode值是否相同。\n                如果相同，还会继续判断元素的equals方法，是否为true。\n    |--TreeSet：可以对Set集合中的元素进行排序。\n                底层数据结构是二叉树。\n                保证元素唯一性的依据：\n                compareTo方法return 0.\n                TreeSet排序的第一种方式：让元素自身具备比较性。\n                元素需要实现Comparable接口，覆盖compareTo方法。\n                也种方式也成为元素的自然顺序，或者叫做默认顺序。\n                TreeSet的第二种排序方式。\n                当元素自身不具备比较性时，或者具备的比较性不是所需要的。\n                这时就需要让集合自身具备比较性。\n                在集合初始化时，就有了比较方式。\n    |--Hashtable:底层是哈希表数据结构，不可以存入null键null值。\n。jdk1.0.效率低。\n    |--HashMap：底层是哈希表数据结构，允许使用 null 值和 null 键，\n。将hashtable替代，jdk1.2.效率高。\n    |--TreeMap：底层是二叉树数据结构。\n。可以用于给map集合中的键进行排序。\n和Set很像。\n其实大家，Set底层就是使用了Map集合。"}
{"title": "mysql优化10条", "content": "大多数的MySQL服务器都开启了查询缓存。\n这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。\n当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，\n这样，后续的相同的查询就不用操作表而直接访问缓存结果了。\n    使用 EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。 EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。 \n加上 LIMIT 1 可以增加性能。MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。 \n索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。\n \n如果你的应用程序有很多 JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。\n而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）  \n \n想打乱返回的数据行？随机挑一个数据？真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。 如果你真的想把返回的数据行打乱了，你有N种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行RAND()函数（很耗CPU时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit 1也无济于事（因为要排序） \n从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。 所以，你应该养成一个需要什么就取什么的好的习惯。\nHibernate性能方面就会差，它不用*，但它将整个表的所有字段全查出来 \n优点：开发速度快\n我们应该为数据库里的每张表都设置一个ID做为其主键，\n而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的 AUTO_INCREMENT标志。 \n就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。\n使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，\n你应该使用表的ID来构造你的数据结构。 而且，在MySQL数据引擎下，还有一些操作需要使用主键，\n在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……\n 在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，\n这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。\n比如：有一个“学生表”有学生的ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，\n其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫“外键”其共同组成主键。 \nENUM 类型是非常快和紧凑的。在实际上，\n其保存的是 TINYINT，但其外表上显示为字符串。\n这样一来，用这个字段来做一些选项列表变得相当的完美。\n如果你有一个字段，比如“性别”，“国家”，“民族”，\n“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，\n你应该使用 ENUM 而不是 VARCHAR。 \n没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。\n具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。\n降低范式就是增加字段，减少了查询时的关联，提高查询效率，因为在数据库的操作中查询的比例要远远大于DML的比例。\n但是反范式化一定要适度，并且在原本已满足三范式的基础上再做调整的。"}
{"title": "（转）目前中国程序员和美国程序员的差距在哪里？", "content": "链接：https://www.zhihu.com/question/20941966/answer/68374958\n我在美国工作过、创业过，在中国工作过，创业过，在 freelancer 上发过外包接过外包，维护过开源项目，请证明比我接触的人多再反对。\n顶尖工程师水平：\n美国 > 中国 > 日本 = 欧洲 = 韩国 > 印度\n平均水平：\n中国 = 美国 > 欧洲 = 印度 > 日本 = 韩国\n 大型互联网公司技术能力：\n美国 > 中国 > 剩下全加起来\n无论公司角度，还是计算机技术能力角度，现在世界上只有两个国家能放在一起说，一个美国，一个中国。\n=====\n统一回复一下。\n我接触过很多三哥，写的代码根本不是人看的，三哥是把计算机和互联网行业当做了低端制造业去做，能力真的不要太高看他们。印度那些外包公司很大程度只是他们能产出大量廉价会说英语的工程师而已，不代表技术又多好。\n毛子和日本其实非常像，都有一些领袖级的人物，但平均水平非常低。我之前接触过一些日本和俄罗斯的公司，他们还在拿至少10年前的那套东西搞开发。\n国内互联网行业从业者千万不要妄自菲薄啊，至少 BAT 的平均水平不会比 Google + Facebook + 苹果的平均水平差多少，国内更多是管理层的问题。真正技术上的差距差在2%的牛逼阶层，这些公司有些叼炸天的大牛，这是国内互联网公司不具备的。真正剩下的98%其实都在一个水平线上。"}
{"title": "Ununtu 安装mysql数据库可视化工具", "content": ""}
{"title": "Linux解压缩命令汇总", "content": "在linux下开发和部署项目，上传的项目和软件包基本上都是压缩文件，Linux常见得压缩格式有zip ,tar,tar.gz.tar.bz2.下面介绍这几种压缩文件的压缩与解压缩。\n 压缩成zip  \n    \n  \n 解压zip    \n     \n 压缩成tar  \n        \n \n 解压tar    \n        \n    压缩成tar.gz                 \n        \n    解压tar         \n        \n    压缩成tar.gz         \n        \n    解压tar \n        \n编者:超锅"}
{"title": "Linux系统安装java", "content": ""}
{"title": "ubuntu Linux完全卸载MySQL及残留方法", "content": ""}
